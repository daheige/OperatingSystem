## 第二章：操作系统简介

[TOC]

如果你正在学习小学二年级的课程，你应该已经有一些关于计算机程序如何运行的了解。如果没有的话，这本书(和相应的课程)学习起来会很困难。——因此你最好停止阅读这本书，或者跑到最近的书店，并在学习必要的前置技术背景之后再继续阅读。

那么程序运行时会发生什么？

一个正在运行的程序做了一件非常简单的事情:**执行指令**。

处理器每秒从内存中 **获取(fetches)** 数百万次(甚至数十亿次)指令，对于每一条指令来说，处理器先进行 **解码(decode)** (即弄清这是哪条指令)，然后 **解释(executes)** 指令(也就是说，可以完成程序应做的事情，比如说数字相加、访问内存、执行函数等等...)。在完成此条指令之后，处理器将继续执行下一条指令，以此类推，直到最终程序完成。

我们刚刚描述了 **冯·诺依曼(Von Neumann)** 计算模型的基础。听起来超级简单对吧？但是在本课中，我们将学习到，在程序运行时，还有许多其他疯狂的东西来使系统更 **易于使用** 。

事实上，有一套软件可以简化程序的运行(甚至可以让你同时运行大量的程序)，它允许程序共享内存，使程序和设备进行交互，以及其他类似的有趣玩意儿。这套软件叫做 **操作系统(OS)** ，它负责确保系统以易于使用的方式正确有效地执行。

操作系统简化程序的主要方式是通过一种叫作 **虚拟化(Virtualization)** 的通用技术。也就是说，操作系统会占用 **物理(physical)** 资源(例如说处理器，内存或硬盘)，将其转化为一个更通用，功能更强大，并且易于使用的 **虚拟(virtual)** 形式。因此，我们有时会将操作系统成为 **虚拟机(virtual machine)** 。

当然，为了允许用户告诉操作系统该怎么做，以利用虚拟机的功能(例如运行程序，分配内存或访问文件)，操作系统还提供了一些可以被用户调用的 **接口(API)** 。实际上，一个典型的操作系统会导出数百个可供应用程序使用的 **系统调用(system calls)** 。因为操作系统提供了这些调用来运行程序、访问内存和设备以及其他相关的操作，所以我们有时也说操作系统为应用程序提供了 **标准库(standard library)** 。

最后，由于虚拟化允许许多程序同时运行(共享CPU)、同时访问自己的指令和数据(共享内存)、访问设备(共享磁盘)，因此操作系统有时也被称为 **资源管理器(resource manager)** 。每个CPU、内存和磁盘都是系统的资源。因此，操作系统的角色就是以高效、公平、或考虑其他目标的方式进行管理这些资源。为了更好的了解操作系统的作用，让我们看一些示例。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int main(int argc, char *argv[])
{
	if (argc != 2) {
		fprintf(stderr, "usage: cpu <string>\n");
		exit(1);
	}
	char *str = argv[1];
	while (1) {
		Spin(1);
		printf("%s\n", str);
	}
	return 0;
}

```

图片2.1: **代码循环并打印** 



## 2.1 虚拟化CPU(Virtualizing the CPU)

图片2.1描叙了我们的第一个程序。程序没有做太多事情。事实上，它做的事情只是调用Spin()函数，该函数反复检查时间并在运行一秒之后返回。程序打印出用户在命令行中传入的字符串，并一直重复下去。

假设我们将此文件另存为cpu.c，决定编译并运行它。在具有单个处理器的系统上，我们将会看到：

```
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC
prompt>
```

系统开始运行程序，它将反复记录时间直到一秒。一秒钟过去之后，代码将打印用户传入的字符串(在此示例中为字母“A”)，然后继续。注意该程序将永远运行；只有按下“Ctrl+C”，我们才能停止该程序。

现在我们来做同样的事情，但是这次我们运行同一程序的许多不同的实例。

图2.2稍微显示了结果

```
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

Figure 2.2:  **一次运行多个程序** 

好了，现在事情开始变得有意思起来了。即使我们只有一个处理器，但是所有的四个程序似乎都在同一时间运行！这是怎么发生的呢？

又一次事实证明，在硬件的一些帮助下，操作系统负责这种 **错觉** ，即系统具有大量虚拟CPU的错觉。

将单个CPU(或其中的一小部分)转变为看似无限数量的CPU，从而使许多程序看似立即运行，这就是我们所谓的 **虚拟化CPU** ，这是本书第一部分的重点。

当然，运行程序然后停止程序。告诉操作系统要运行哪些程序，需要使用一些接口(API)将所需信息传达给OS。我们将在整本书中讨论这些API；接口是大多数用户与操作系统进行交互的主要方式。

你可能还会注意到，一次运行多个程序会引发各种各样的新问题。

例如，如果两个程序都在特定时间运行，哪个应该运行？这就要问操作系统的 **策略(Policy)** 了；策略被用于操作系统中的许多不同的地方来解答这种类型的问题，当我们了解操作系统实现的基本机制(例如一次运行多个程序)时，将对它们进行研究。操作系统作为资源管理器当之无愧。

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[])
{
	int *p = malloc(sizeof(int)); // a1
	assert(p != NULL);
	printf("(%d) memory address of p: %08x\n",
		getpid(), (unsigned) p); // a2
	*p = 0; // a3
	while (1) {
		Spin(1);
		*p = *p + 1;
		printf("(%d) p: %d\n", getpid(), *p); // a4
	}
	return 0;
}
```

Figure 2.3:  **一个访问内存的程序** (mem.c)

## 2.2 虚拟化内存(Virtualizing Memory)

现在我们来考虑 **内存(Memory)** 。

现代计算机提供的 **物理内存(physical memory)** 模型非常简单，内存就是一个字节(bytes)数组；要 **读取(read)** 内存，必须指定一个 **地址(address)** 来访问存储在其中的数据；要 **写入(write)或更新(update)** 内存的话必须指定要写入给定地址的数据。

程序运行时会一直访问内存。程序将它的所有数据结构都保存在内存中，并通过各种指令(例如加载、存储或其他在程序运行中访问内存的显式指令)访问它们。不要忘记程序的每个指令也都在内存中；因此处理器每次获取指令时都访问内存。

让我们看一个程序(图2.3)，该程序通过调用malloc()的方法分配一些内存。该程序的输出可以在这里找到：

```
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
```

该程序可以做几件事。首先，它分配一些内存(a1)。然后，它打印出内存的(a2)地址，接着将数字0放入新分配的内存(a3)的第一个插口(slot)中。最后，它开始循环，等待一秒钟，然后递增存储在p中保存的地址中的值。对于每个printf语句，它还会打印出正在运行的程序的进程标识符(PID)。 该PID在每个运行过程中都是唯一的。

```
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
```

Figure2.4 **多次运行内存程序** 

同样的，第一个结果不怎么有趣。新分配的内存位于地址00200000。在程序运行时，它将缓慢更新值并打印出结果。

现在，我们再次运行同一程序的多个实例，来看看会发生什么(图2.4)。

从示例中我们看到，每个正在运行的程序都在相同的地址上(00200000)上分配了内存，但是每个程序似乎都在独立地更新00200000的值！好像每个正在运行的程序都有自己的专用内存，而不是与其他正在运行的程序共享相同的物理内存。

有一说一，确实，这正是操作系统 **虚拟化内存(virtualizing memory)** 时发生的情况。每个进程都访问自己的 **私有虚拟地址空间(virtual address space)** (有时直接称地址空间)，操作系统以某种方式将其映射到计算机的物理内存上。访问一个正在运行的程序中的内存不会影响其他进程(或者OS本身)的地址空间。就正在运行的程序而言，它本身具有物理内存。但是，实际情况是物理内存是由操作系统管理的共享资源。那么如何实现所有这些目标呢，就得看本书第一部分的主题—— **虚拟化(virtualization)** 了。

## 2.3 并发(Concurrency)

这本书的另一个主题是 **并发(Concurrency)** .当在同一程序中同时处理很多事情时，我们使用 **并发** 这个概念性术语来指代它出现的一系列问题。

并发问题首先出现在操作系统本身。

正如你在上面有关虚拟化的示例中所看到的那样，操作系统一次要处理很多事情，首先运行一个进程，然后运行另一个，以此类推。但这样做会导致一些深刻又有趣的问题。

```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		counter++;
	}
	return NULL;
}

int main(int argc, char *argv[])
{
	if (argc != 2) {
	fprintf(stderr, "usage: threads <value>\n");
	exit(1);
	}
	loops = atoi(argv[1]);
	pthread_t p1, p2;
	printf("Initial value : %d\n", counter);
    
	Pthread_create(&p1, NULL, worker, NULL);
	Pthread_create(&p2, NULL, worker, NULL);
	Pthread_join(p1, NULL);
	Pthread_join(p2, NULL);
	printf("Final value : %d\n", counter);
	return 0;
}
```

Figure 2.5：**多线程程序** （threads.c）

不幸的是，并发问题不仅仅局限于操作系统本身。现代 **多线程(multi-threaded)** 程序也存在相同的问题。让我们以一个多线程程序来进行演示。(图2.5)

尽管你可能暂时还没有完全理解这个实例，但是基本思想很简单，主程序使用 *Pthread_create()* 创建了两个 **线程(threads)** 。你可以把线程理解成和其他函数一样运行在相同内存空间的函数，一次有多个线程处于活动状态。在这个例子中，每个线程从一个名为 *worker()* 的例程中运行，在这个例程里，它只是简单地在循环中递增 *counter* 次数。

下面是当我们在将循环的输入值设置为1000的情况下运行此程序时发生的记录。

循环的值确定两个 *worker()*  程序中的每一个将在循环中递增共享 *counter* 的次数。在将循环值设置为1000的情况下运行程序，你觉得counter的最终值会是多少？

```
prompt> gcc -o thread thread.c -Wall -pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
```

就像你猜的那样，当两个线程完成时，最后一个计数器的值是2000，因为每个线程将计数器递增1000次。确实，当循环的输入值设置为N的时候，我们期望程序的最终输入为2N。但是生活没有那么简单，这次让我们运行相同的程序，但是使用更高的循环值，看看会发生什么：

```
prompt> ./thread 100000
Initial value : 0
Final value : 143012 // 啥玩意儿??
prompt> ./thread 100000
Initial value : 0
Final value : 137298 // 这又是啥玩意儿??
```

在这次运行中，当我们给定输入为 100,000 的时候，我们并没得到 200,000。而是得到了143,012这样一个值。然后在我们第二次运行程序的时候，我们不仅得到错误的值，而且这个值还和上一个值不一样！实际上，如果你以较高的循环值一遍又一遍地运行程序，你可能会发现有时你居然会得到正确答案。那么为什么会这个样子呢？

事实证明，产生这些奇怪结果的原因和指令的执行方式有关，程序是一次执行一条指令。但是不幸的是，上面程序的关键部分( *the shared counter is incremented* )需要执行三条指令：一条将计数器的值从内存中加载到寄存器中，一条将 *counter* 递增，另一条将其存储回内存中。由于这三个指令不是一次执行的，所以可能会发生奇怪的事情。

**并发性** 的问题将在本书的第二部分详细讨论 :)。

```c
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>

int main(int argc, char *argv[])
{
int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
    assert(fd > -1);
    int rc = write(fd, "hello world\n", 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
```

Figure 2.6:  **一个执行I/O的程序** (io.c)

## 2.4 持久性(Persistence)

本课程的第三个主要主题是 **持久性(persistence)** 。在系统内存中，数据很容易丢失，因为诸如DRAM之类的设备以 **易失(volatile)** 的方式存储值。当电源咔嚓或系统崩溃时，内存中的所有数据都会丢失。

因此，我们需要能够持久存储数据的硬件和软件。用户们是非常关心自己的数据的，因此，这种存储对于任何系统都是至关重要的。

硬件以某种输入/输出或I/O设备的形式出现。在现代系统中， **硬盘(hard drive)**  是 长期信息的常用存储库。现在 **固态硬盘(SSD)** 也在这个领域发光发彩了。

操作系统中通常把管理磁盘的软件叫做 **文件系统(file system)** ; 它负责将用户创建的任何文件以可靠有效的方式存储在系统硬盘上。

与操作系统为CPU和内存提供的抽象不同，操作系统不会为每个应用程序创建专用的虚拟化硬盘。相反，假设用户希望共享文件中的信息。例如，编写C语言程序的时候，你可能会先用到编辑器(例如VSCode)来创建和编辑 *.C file* 。完成后，你可能使用编译器将源代码转换为可执行文件(gcc -o main main.c)。然后你就可以执行了(./main)。

因此，你会注意到如何在不同进程之间共享文件了。

首先VSCode创建一个文件作为编译器的输入；编译器使用该输入文件来创建新的可执行文件。最后，新的可执行文件运行。就这样，一个新程序就诞生了！

为了更好地理解这一点，让我们来看一段代码。图2.6显示了一段 “创建一个包含字符串"Hello World"的文件(/tmp/file)” 的代码。

为了完成这个任务，该程序对操作系统进行了三个调用。第一个调用 *open()* ,打开并创建文件；第二个是 *write()* , 将一些数据写入文件; 第三个 *close()* ,关闭文件，表示程序不会再向其中写入任何数据。这些系统调用被路由到操作系统里被称为文件系统的那部分，然后该文件系统处理请求并向用户返回某种错误代码。

你可能想知道操作系统为了把数据写入磁盘需要做什么。我们会告诉你，但是你最好闭上你的眼睛，就是那么让人不爽。文件系统需要做很多很多工作：首先要确定新数据将在磁盘上驻留的位置，然后以文件系统维护的各种结构来跟踪它。然后需要向基础存储设备发出I/O请求，以读取现有结构或更新(写入)它们。正如任何编写过 **设备驱动程序(device driver)** 的人都知道的那样，让设备替代你做某件事时一个复杂而又详细的过程。它需要对底层设备接口及其确切语义有深入理解。幸运的是，操作系统提供了一种标准且简单的方式来通过系统调用访问设备。

因此，有时会将OS视为 **标准库(standard library)** 。

当然，在如何访问设备以及文件系统如何在所述设备之上持久地管理数据方面，还有许多其他细节。出于性能原因，大多数文件系统首先将此类写入延迟一点儿，希望将他们分成更大的组。为了解决写入过程中系统崩溃的问题，大多数文件系统都采用了某种复杂的写入协议，例如日志记录(journaling)或写入时复制(copy-on-write)，仔细地对磁盘进行排序，以确保如果在写入序列期间发生故障，系统之后可以恢复到合理的状态。为了使不同的常用操作高效，文件系统采用了许多不同的数据结构和访问方法，从简单列表到复杂的B-Tree。

在本书的第三部分中，我们将更多地讨论所有的有关持久性的问题，我们将会讨论设备和I/O，然后再详细地讨论磁盘，RAID和文件系统。

## 2.5 设计目标(Design Goals)

现在，你对操作系统的实际功能有了一点了解：它需要物理资源(例如CPU,内存或硬盘)并将其虚拟化。它处理与并发相关的棘手问题。而且它持久地存储文件，使它们长久安全。考虑到我们要构建这样一个系统，我们希望牢记一些目标，来帮助我们集中设计和实现并在必要时进行权衡。

找到正确的权衡是构建系统的关键。

最基本的目标之一是建立一些抽象，以使系统方便使用。抽象是我们从事计算机科学工作的基础。通过抽象，可以将大型程序分成小段、易于理解的段来编写，无需考虑汇编，使用诸如C语言之类的高级语言就可以编写此类程序，无需考虑逻辑门就可以使用汇编、无需过多考虑晶体管就可以摆脱处理器的束缚。抽象相当重要，以至于有时我们竟忘记了它的重要性。因此，在每个部分中，我们将讨论随着时间的推移而发展的一些主要抽象，为您提供一种思考操作系统的方式。

设计和实现操作系统的目标之一是提供高性能。换句话说，我们的目标是最大程度的减少操作系统的开销。虚拟化和使系统易于使用非常值得，而且还不产生开销。因此，我们必须努力提供虚拟化和其他OS功能，而又不会产生太多的开销。这些开销有多种方式：额外的 **时间(更多的指令)** 和额外的 **空间(内存或硬盘中)** 。如果可能的话，我们将寻求将两者之一或两者都最小化的解决方案。然而，并非所有东西都能做到完美。

另一个目标将是在应用程序之间以及操作系统和应用程序之间提供 **保护(protection)** 。因为我们希望允许多个程序同时允许，所以我们要确保一个程序的恶意或偶然不良行为不会损坏其他程序；我们当然更不希望应用程序损害操作系统本身(这会影响系统上允许的所有程序)。保护是操作系统的主要原则之一的核心，即 **隔离(isolation)** 。将进程彼此隔离是保护的关键，因此隔离成为操作系统必须执行的许多工作中的基础。

操作系统还必须不间断的运行；当它停止时，系统上运行的所有应用程序也都会停止。由于这种 **依赖性(dependence)** ，操作系统经常努力提供高度的 **可靠性(reliability)** 。随着操作系统变得越来越复杂(有时包含数百万行代码)，构建可靠的操作系统会是一个巨大的挑战。

实际上，该领域中进行的很多研究(BS +9,BS +10)都集中在这个确切的问题上。

其他目标也很有意义:在我们日益绿色的世界中，能源效率至关重要、防止恶意应用程序的安全至关重要、操作系统在越来越小的设备上运行，移动性变得越来越重要......根据系统的使用方式，操作系统将具有不同的目标，因此可能至少以略有不同的方式实现。 但是，正如我们将看到的，我们将介绍的有关如何构建OS的许多原理在许多不同的设备上都是有用的。

## 2.6 总结(Summary)

我们对操作系统进行了介绍。当今的操作系统使系统相对易于使用，并且如今使用的几乎所有的操作系统都受到了我们整本书将讨论的发展的影响。

我们将涉及许多重要主题，包括CPU和内存虚拟化的基础知识，并发性以及通过设备和文件系统的持久性。尽管有很多方面需要介绍，但是不用担心，其中大部分内容都很酷！在开发的最后，您将对计算机系统的真正工作方式有了新的认识。

现在，让我们开始吧！